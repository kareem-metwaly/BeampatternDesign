"""implements a dataset loader that reads the desired beampattern and the
optimum waveform generated by matlab code."""
import typing as t
import warnings

import torch
from datasets.base_dataset import BaseDataset
from losses.objective import Objective
from pymatreader import read_mat
from torchvision.transforms import ToPILImage
from tqdm import tqdm
from utils.base_classes import TrainMode
from utils.config_classes import DatasetConfig
from utils.etc import list_files_with_ext
from utils.item_classes import DatasetItem
from utils.types import FilePath


class BeamPattern(BaseDataset):
    """This is a PyTorch implementation to work in training to retrieve data.

    data should be stored in mat format and has the following variables:
     - `OptimizedWaveform` contains the result of the PDR algorithm
     - `DesiredBeampattern` contains the input desired beampattern
    """

    files: list[FilePath]

    def __init__(self, configs: DatasetConfig):
        """Specifies the configs, fetches the files from directory, and perform
        sanity check.

        :param configs: (DatasetConfig)
        """
        super().__init__(configs=configs)
        # getting files
        self.files = [
            file for file in list_files_with_ext(self.configs.data_path, ext="mat") if "parameters" not in file.name
        ]
        if self.configs.perform_sanity:
            self.sanity_check()

    def sanity_check(self):
        """
        go through the data quickly to make sure that every thing works well and nothing is wrong,
        if there is an issue with reading the data we remove it from the list of files
        :return: Nothing
        """
        files = self.files
        to_remove = []
        for idx in tqdm(range(len(files))):  # loop through files and read its contents
            if not self._get_item_with_assertion(idx):
                to_remove.append(idx)
        if to_remove:
            warnings.warn(
                "Removing the following files as they are corrupted \n"
                f"files = {[file for idx, file in enumerate(files) if idx in to_remove]}"
            )
            self.files = [file for idx, file in enumerate(files) if idx not in to_remove]

    def _get_item_with_assertion(self, index: int) -> t.Optional[DatasetItem]:
        """Checks whether the retrieved values are sane.

        :param index: (int)
        :return: DatasetItem
        """
        item = self[index]
        if item:
            assert len(item.optimum_waveform.shape) == 1
            assert len(item.desired_beampattern.shape) == 2
            assert len(item.optimum_waveform) == self.configs.params.N * self.configs.params.M
            assert item.desired_beampattern.shape == (self.configs.params.K, self.configs.params.N)
            assert item.optimum_waveform.is_complex(), (
                f"The waveform must be complex,\n" f"got {item.optimum_waveform.dtype}"
            )
            assert item.desired_beampattern.is_complex(), (
                f"The beampattern must be converted to complex first,\n" f"got {item.desired_beampattern.dtype}"
            )
        return item

    def __getitem__(self, index: int, mode: TrainMode = TrainMode.Unspecified) -> t.Optional[DatasetItem]:
        """Gets one sample from the dataset without performing sanity check."""
        file_path = self.files[index]
        try:
            data = read_mat(str(file_path))
        except Exception as e:
            print("There was an error in reading " + str(file_path))
            print(e)
            return None

        optimum_waveform = torch.tensor(data["OptimizedWaveform"])
        desired_beampattern = torch.tensor(data["DesiredBeampattern"]).to(torch.complex64)
        sample = self.preprocess_sample(
            DatasetItem(optimum_waveform=optimum_waveform, desired_beampattern=desired_beampattern, filepath=file_path)
        )
        return sample

    def __len__(self) -> int:
        """the size of the dataset."""
        return len(self.files)

    def preprocess_sample(self, dataset_item: DatasetItem) -> DatasetItem:
        """we may need to perform some preprocessing such as normalization of
        the range of values."""
        max_val = self.configs.params.N  # desired beampattern has min value of 0 and max of N
        dataset_item.desired_beampattern /= max_val  # now it is in the range of 0, 1
        assert (dataset_item.optimum_waveform.abs().round(decimals=4) == 1).all(), (
            f"Some values are not feasible such as: "
            f"{dataset_item.optimum_waveform[dataset_item.optimum_waveform.abs().round(decimals=4) != 1]}"
        )
        return dataset_item

    def plot_sample(self, sample: DatasetItem) -> None:
        objective = Objective(dataset_configs=self.configs)
        estimated = objective.estimated_beampattern(sample.optimum_waveform.unsqueeze(0)).squeeze()
        ToPILImage()(estimated).show()
        ToPILImage()(sample.desired_beampattern.abs()).show()
